<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://prashantrahul.com name=base><meta name=darkreader-lock><title>
         Persistence and Filesystems
        
    </title><meta content="Persistence and Filesystems" property=og:title><meta content="I am an undergraduate junior interested in building and tinkering with compilers and interpreters. I also work on emulators, graphics APIs, games, cross-platform applications, and full-stack web experiences." property=og:description><meta content=https://raw.githubusercontent.com/prashantrahul141/prashantrahul141.github.io/refs/heads/main/static/icons/logo.png property=og:image><meta content="I am an undergraduate junior interested in building and tinkering with compilers and interpreters. I also work on emulators, graphics APIs, games, cross-platform applications, and full-stack web experiences." name=description><link href=/icons/favicon.ico rel=icon type=image/png><link href=https://prashantrahul.com/fonts.css rel=stylesheet><script src=https://prashantrahul.com/js/codeblock.js></script><script src=https://prashantrahul.com/js/toc.js></script><script src=https://prashantrahul.com/js/note.js></script><script src=https://prashantrahul.com/js/gallery-images.js></script><link href=https://prashantrahul.com/atom.xml rel=alternate title=~/prashant type=application/atom+xml><script>MathJax = {
                    tex: {
                        inlineMath: [
                            ['$', '$'],
                            ['\\(', '\\)']
                        ]
                    }
                };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://prashantrahul.com/theme/light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://prashantrahul.com/theme/dark.css rel=stylesheet><script src=https://prashantrahul.com/js/themetoggle.js></script><script>if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    setTheme("dark");
                } else {
                    setTheme("light");
                }</script><link href=https://prashantrahul.com/main.css media=screen rel=stylesheet><body><div class=content style=margin-bottom:6rem><header><div class=main><a class=logo href=https://prashantrahul.com> <img alt=~/prashant height=640 src=https://prashantrahul.com/icons/logo.avif width=640> </a></div><nav><a href=https://prashantrahul.com/posts style=margin-left:1.3em>~/posts</a><a href=https://prashantrahul.com/gallery style=margin-left:1.3em>~/gallery</a><a href=https://prashantrahul.com/Prashant-Rahul-CV.pdf style=margin-left:1.3em target=_blank>~/resume</a></nav></header><main><article><div class=title><div class=page-header>Persistence and Filesystems<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2026-02-27</time> :: <time>9</time> Min Read <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://prashantrahul.com/tags/tech/>tech</a>, <a class=post-tag href=https://prashantrahul.com/tags/filesystem/>filesystem</a>, <a class=post-tag href=https://prashantrahul.com/tags/operating-systems/>operating systems</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#foreword>Foreword</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#persistence>Persistence</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#filesystems>Filesystems</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#files-directories>Files & Directories</a> <ul><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#files>Files</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#directories>Directories</a></ul><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#the-structure>The Structure</a> <ul><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#blocks>Blocks</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#the-inode>The Inode</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#bitmaps>BitMaps</a><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#superblock>Superblock</a></ul><li><a href=https://prashantrahul.com/posts/persistence-and-file-systems/#finishing>Finishing</a></ul></div><section class=body><h1 id=foreword><a aria-label="Anchor link for: foreword" class=zola-anchor href=#foreword>Foreword</a></h1><p>Recently, I have been reading a lot about operating systems, especially those with hard time constraints, commonly known as Real Time Operating Systems aka RTOS. I have been experimenting with <a href=https://rtems.org/ target=_blank> RTEMS</a> and have even contributed upstream.<p>During this time, I started reading about filesystems and how they are implemented. I am currently following the OSDev wiki page on <a href=https://wiki.osdev.org/File_Systems target=_blank> filesystems</a> and Part 3, “Persistence,” of the book <a href=https://pages.cs.wisc.edu/~remzi/OSTEP/ target=_blank> Operating Systems: Three Easy Pieces</a> , along with similar articles on the internet. And filesystems are fascinating to say the least.<p>In this short writing, I make an attempt at trying to explain what I understood and things that amazed me about filesystems.<h1 id=persistence><a aria-label="Anchor link for: persistence" class=zola-anchor href=#persistence>Persistence</a></h1><p>Persistence is the characteristic of data or a system state to outlive the process that created it. For example, if you create a text file <code>hello.txt</code> with the content "Hello World", even after you close your text editor and shut down your computer, you can turn your computer on again and inspect the file to see that the contents are still present. This is a very crude explanation, but that is basically persistence in this context.<h1 id=filesystems><a aria-label="Anchor link for: filesystems" class=zola-anchor href=#filesystems>Filesystems</a></h1><p>As with every component in an operating system, a filesystem is an abstraction over something else, over disks and other storage media, and Linux takes this to the extreme. There are actual hardware devices represented as normal files in the tree hierarchy. Don’t believe me? Run:<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>cat</span><span> /dev/input/mice
</span></code></pre><p>Then move your mouse. You will see seemingly random characters printed in the terminal, that is literally what your mouse is sending to the kernel via USB.<p>Filesystems provide an abstraction and an easy interface to read and write data and even persist it without worrying about how the data is handled, stored, or managed.<h1 id=files-directories><a aria-label="Anchor link for: files-directories" class=zola-anchor href=#files-directories>Files & Directories</a></h1><p>There are two different types of abstractions created by filesystems, Files and Directories.<h2 id=files><a aria-label="Anchor link for: files" class=zola-anchor href=#files>Files</a></h2><p>A file is, as it appears on the surface, an array of bytes with a name associated with it. Operating systems do not know the type of data it stores, it could be a text file, a PNG image, or even executable code. Rather, the operating system only cares about ensuring that the data is persisted across reboots with consistency and no data loss.<p>A file also has an internal number commonly referred to as the inumber or inode number. This can be thought of as the “internal unique name” used by the operating system. We will learn more about inodes later.<h2 id=directories><a aria-label="Anchor link for: directories" class=zola-anchor href=#directories>Directories</a></h2><p>Directories, on the other hand, appear to contain other files and directories in a tree like structure. In most filesystems, directories contain a set of pairs consisting of a human readable name and the inumber of the files and directories they contain.<p>This creates a tree like hierarchy in which directories can contain files and other directories. In most Unix like systems, there is also a concept of a root directory, commonly denoted by <code>/</code>. It is the topmost directory, which contains all other files and directories.<p>Here is an example of such structure:<p align=center><img alt=hierarchy src=/posts/images/0005.png><p>This has one root directory, denoted by <code>/</code>, which contains a file named <code>foo.txt</code> and a directory named <code>bar</code>. This <code>bar</code> directory contains a file <code>cta.png</code> and another directory named <code>bar</code>, overall creating a structure that resembles a tree. These underlying files and directories can be referenced using a “path.” A path is a collection of human readable names of files or directories joined together by a delimiter. In most Unix systems, this delimiter is simply <code>/</code>. For instance, the file <code>cta.png</code> can be referenced as <code>/bar/cta.png</code>.<p>If you inspect <code>bar</code> directory it would look something like:<pre style=color:#61676c;background-color:#fafafa><code><span>[
</span><span>   ("."      ,  21262482),
</span><span>   (".."     ,  21261953),
</span><span>   ("baz"    ,  21261951),
</span><span>   ("cta.png",  21262481),
</span><span>]
</span></code></pre><p>We find our file <code>cta.png</code> and the directory <code>bar</code>, but what are <code>.</code> and <code>..</code>? In most Unix like operating systems, <code>.</code> denotes the current directory and <code>..</code> denotes the parent directory. Even empty directories, at the very least, contain these two entries in order to maintain the tree structure.<p>You can inspect this right now by running:<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>ls</span><span style=color:#ff8f40> -lia -a
</span></code></pre><p align=center><img alt="ls output" src=/posts/images/0006.png><p>Also, the numbers you see on the left are inode numbers of the respective entries as it is in the filesystem.<p>Another thing to keep in mind is that there is no enforcement that a file name ending with <code>.png</code>, such as our <code>cta.png</code>, must actually be a PNG file. This is merely a convention.<h1 id=the-structure><a aria-label="Anchor link for: the-structure" class=zola-anchor href=#the-structure>The Structure</a></h1><p>There are a million different ways to implement filesystems, all of which have different advantages and disadvantages. The one I am going to discuss here is extremely simple and barely scratches the surface.<h2 id=blocks><a aria-label="Anchor link for: blocks" class=zola-anchor href=#blocks>Blocks</a></h2><p>The first step in implementing a filesystem is to divide the storage medium into fixed (though not always) chunks, since disk reads and writes do not occur at the byte level but rather in chunks.<p>Imagine we have 256KB of memory<p align=center><img alt="256KB of memory" src=/posts/images/0007.png><p>We will divide this memory into 4 KB chunks. They are grouped into sets of eight only for easier understanding and do not hold any special meaning.<p align=center><img alt="256KB of memory in blocks" src=/posts/images/0008.png><p>So, what do we store in these blocks? The first thing that comes to mind is user data. Let’s say we reserve blocks 8 to 63 for this purpose.<p align=center><img alt="User data in 256KB of memory in blocks" src=/posts/images/0009.png><p>But we also need to store information such as permissions, modification date, creation date, its owner, and other similar details, we need to store metadata.<h2 id=the-inode><a aria-label="Anchor link for: the-inode" class=zola-anchor href=#the-inode>The Inode</a></h2><p>The Index Node, or Information Node, commonly referred to simply as the inode, is a core data structure in filesystems. Almost every filesystem you have ever heard of has some form of inode. Take a look at the inode used in the <a href=https://docs.kernel.org/filesystems/ext4/ target=_blank> ext4</a> filesystem as it is defined inside the Linux kernel <a href=https://github.com/torvalds/linux/blob/7dff99b354601dd01829e1511711846e04340a69/fs/ext4/ext4.h#L795 target=_blank> here</a><p>Each inode has a unique number known as its inumber, this is the “internal name” discussed earlier. An inode can store all kinds of information you would want in your filesystem, such as the block number it points to, how many blocks it occupies, file size, modification date, creation date, owner, and much more.<p>For our filesystem, let's say the size of a single inode structure is exactly 256 bytes, so one 4KB block can store exactly 16 inodes<p>$inodeSize = 256$<p>$blockSize = 4 \times 1024$<p>$blockCount = blockSize \div inodeSize$<p>$= (4 \times 1024) \div 256$<p>$= 16$<p>If we consider 5 blocks for our inodes, we should be able to store $(5 \times 4 \times 1024) \div 256$ or $80$ inodes. That is more than enough for our 64 blocks memory.<p align=center><img alt="User data and inodes in 256KB of memory in blocks" src=/posts/images/0010.png><p>Individual inodes would look something like this:<p align=center><img alt="zoomed in view of inodes" src=/posts/images/0011.png><p>Another property we require from our filesystem is that, given the number of an inode, it should be able to compute where that inode is stored on disk.<p>So, for example, let's say we want to retrieve the inode 32, since we know the size of each inode (256 Bytes) and the base address of the first inode (start of forth inode, 12KB), we can compute the address of inode 32 by doing:<p>$offset = sizeof(inode\_t) \times 32$<p>$addr = baseAddr + offset$<p>$= (12 \times 1024) + (256 \times 32)$<p>$= 20480$<p>$= 20KB$<p>We can retrieve any specific inode but how do you we know if a inode or a data block is free or occupied?<h2 id=bitmaps><a aria-label="Anchor link for: bitmaps" class=zola-anchor href=#bitmaps>BitMaps</a></h2><p>There are multiple ways of tracking free nodes, but we are going to examine the most basic one: bitmaps. A bitmap is a very simple structure, a chunk of memory representing whether a block is free (bit set to 0) or occupied (bit set to 1).<p>In our case, where each block is 4 KB in size, one block could represent $4 \times 1024 \times 8$, or $32{,}768$ blocks. That is more than enough for storage of this size, but we would need two of these: one for inodes and one for user data blocks.<p align=center><img alt="User data, inodes, bitmaps in 256KB of memory in blocks" src=/posts/images/0012.png><h2 id=superblock><a aria-label="Anchor link for: superblock" class=zola-anchor href=#superblock>Superblock</a></h2><p>In modern Unix systems, you can have multiple types of filesystems at the same time, mounted at different mount points. Mounting is essentially connecting the root of one filesystem to a path within another filesystem. You can list all these mount points by running the <code>mount</code> command without any arguments.<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>$</span><span> mount
</span><span style=color:#f29718>devtmpfs</span><span> on /dev type devtmpfs (rw,nosuid,size=788808k,nr_inodes=1965778,mode=755)
</span><span style=color:#f29718>devpts</span><span> on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=3,mode=620,ptmxmode=666)
</span><span style=color:#f29718>...
</span><span style=color:#ed9366>&lt;</span><span>REDACTED </span><span style=color:#f29718>FOR</span><span> SANITY</span><span style=color:#ed9366>>
</span><span style=color:#f29718>...
</span><span style=color:#f29718>binfmt_misc</span><span> on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,nosuid,nodev,noexec,relatime)
</span><span style=color:#f29718>tmpfs</span><span> on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=1577612k,nr_inodes=394403,mode=700,uid=1000,gid=100)
</span><span style=color:#f29718>gvfsd-fuse</span><span> on /run/user/1000/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_id=1000,group_id=100)
</span><span style=color:#f29718>portal</span><span> on /run/user/1000/doc type fuse.portal (rw,nosuid,nodev,relatime,user_id=1000,group_id=100)
</span></code></pre><p>As you can see, there are more than 25 different filesystems mounted on my machine at the same time. It is therefore crucial for the operating system to understand and treat them accordingly, because each behaves differently and has different properties and parameters. How does the operating system know this?<p>We place a special block at the beginning of the storage medium that stores metadata about the filesystem itself, such as the block size, supported features, version, and more. The operating system can read this information and determine the type of filesystem it is operating with.<p align=center><img alt="User data, inodes, bitmaps and superblock in 256KB of memory in blocks" src=/posts/images/0013.png><h1 id=finishing><a aria-label="Anchor link for: finishing" class=zola-anchor href=#finishing>Finishing</a></h1><p>This filesystem has several limitations, such as not being able to handle large files, missing support for symbolic links and cleanup system, suffering from fragmentation, and much more, but it is a starting point nonetheless. It can be further extended by studying other filesystems like <a href=https://en.wikipedia.org/wiki/Ext4>ext4</a> or even a flash filesystem like <a href=https://en.wikipedia.org/wiki/JFFS2>jffs2</a> but until next time.</p><br><hr><br><div align=center><button onclick="window.scrollTo({ top: 0,left: 0,behavior: 'smooth'})" title="Jump to top">^^</button></div></section></article></main></div>