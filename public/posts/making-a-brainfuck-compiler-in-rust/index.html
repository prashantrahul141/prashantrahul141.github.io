<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://prashantrahul.com name=base><title>
         Making a Brainfuck compiler in Rust
        
    </title><meta content="Making a Brainfuck compiler in Rust" property=og:title><meta content="I am a software developer working in a lot of fields with a specialization in building and tinkering compilers and interpreters. I also work on creating full-stack web experiences, emulators, graphics APIs, games and cross platform applications." property=og:description><meta content="I am a software developer working in a lot of fields with a specialization in building and tinkering compilers and interpreters. I also work on creating full-stack web experiences, emulators, graphics APIs, games and cross platform applications." name=description><link href=/icons/favicon.ico rel=icon type=image/png><link href=https://prashantrahul.com/fonts.css rel=stylesheet><script src=https://prashantrahul.com/js/codeblock.js></script><script src=https://prashantrahul.com/js/toc.js></script><script src=https://prashantrahul.com/js/note.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://prashantrahul.com/atom.xml rel=alternate title=~/prashant type=application/atom+xml><link href=https://prashantrahul.com/theme/dark.css rel=stylesheet><link href=https://prashantrahul.com/main.css media=screen rel=stylesheet><script src=https://prashantrahul.com/js/mermaid.js></script><body><div class=content style=margin-bottom:6rem><header><div class=main><a class=logo href=https://prashantrahul.com> <img alt=~/prashant src=https://prashantrahul.com/icons/logo.png> </a></div><nav><a href=https://prashantrahul.com style=margin-left:1.3em>~/prashant</a><a href=https://prashantrahul.com/posts style=margin-left:1.3em>~/posts</a><a href=https://prashantrahul.com/gallery style=margin-left:1.3em>~/gallery</a></nav></header><main><article><div class=title><div class=page-header>Making a Brainfuck compiler in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-02-24</time> :: <time>8</time> Min Read <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://prashantrahul.com/tags/rust/>rust</a>, <a class=post-tag href=https://prashantrahul.com/tags/brainfuck/>brainfuck</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#links>Links</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#so-what-is-brainfuck>So What is brainfuck?</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#how-does-the-language-work>How does the language work?</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#lexical-analysis>Lexical Analysis</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#parsing>Parsing</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#vm>VM</a><li><a href=https://prashantrahul.com/posts/making-a-brainfuck-compiler-in-rust/#connecting-everything-into-a-beautiful-pipeline>Connecting everything into a beautiful pipeline.</a></ul></div><section class=body><h1 id=links><a aria-label="Anchor link for: links" class=zola-anchor href=#links>Links</a></h1><p>brainf*ck wikipedia: <a href=https://en.wikipedia.org/wiki/Brainfuck target=_blank> https://en.wikipedia.org/wiki/Brainfuck </a><p>brainf*ck basics: <a href=https://gist.github.com/roachhd/dce54bec8ba55fb17d3a target=_blank> https://gist.github.com/roachhd/dce54bec8ba55fb17d3a </a><p>source: <a href=https://github.com/prashantrahul141/bf-interpreter-rs target=_blank> https://github.com/prashantrahul141/bf-interpreter-rs </a><h1 id=so-what-is-brainfuck><a aria-label="Anchor link for: so-what-is-brainfuck" class=zola-anchor href=#so-what-is-brainfuck>So What is brainfuck?</a></h1><p>lets look up on wikipedia<p><img alt="Brainfuck on wikipedia" src=/posts/images/0001.png><p>so basically its an programming language which works with only 8 simple commands, and here are the 8 simple commands:<p><img alt="Brainfuck on wikipedia" src=/posts/images/0002.png><p>you might be wondering how you can make something with only these 8 commands to work with<h1 id=how-does-the-language-work><a aria-label="Anchor link for: how-does-the-language-work" class=zola-anchor href=#how-does-the-language-work>How does the language work?</a></h1><p>imagine a really long line of cells with values stored in the cells, initially all of the values will be zero, we will call this "memory"<pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span>
</span></code></pre><p>now imagine a pointer, pointing to one of the cell in the memory, initially it will point at the first cell.<pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span>                                  ^
</span></code></pre><pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span> ^
</span></code></pre><p>all the operations you do using the 8 commands will be done on the memory and using this simple pointer. you can move the pointer to one cell to right using the right angle bracket operator '>'<pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span>    ^
</span></code></pre><p>you can move the pointer to one cell to left using the left angle bracket operator '<'<pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span> ^
</span></code></pre><p>you can increment the value in the cell, which is currently being pointed at using the plus operator '+'<pre style=color:#61676c;background-color:#fafafa><code><span>[1][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span> ^
</span></code></pre><p>you can decrement the value in the cell, which is currently being pointed at using the minus operator '-'<pre style=color:#61676c;background-color:#fafafa><code><span>[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span> ^
</span></code></pre><p>you can print the value of the cell currently being pointed at in ascii text using the dot operator '.', so if the value is, lets say 83,<pre style=color:#61676c;background-color:#fafafa><code><span>[83][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]
</span><span> ^
</span></code></pre><p>if we look up the value of ascii code 83,<p><img alt="ascii table" src=/posts/images/0003.png><p>its capital 'S', so the dot '.' operator will print a capital "S".<p>you can read data from user using the comma "," operator, it will save the data in the cell which is currently pointed at.<p>and finnaly the opening and closing bracket operators "[" "]".<p>the opening bracket operator says, if the data at currently pointed cell is zero, then instead of continuing the execution normally, jump directly to the instruction which comes after the closing bracket operator "]" its like a loop and if statement combined.<p>and thats basically it, that's all you need to make a turing complete programming language. I present to you "Hello World!" program in brainfuck.<pre class=language-bf data-lang=bf style=color:#61676c;background-color:#fafafa><code class=language-bf data-lang=bf><span>>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]
</span><span>>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]&LT-.--------.+++
</span><span>.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
</span></code></pre><p>now, i would really like to talk more about the language and how people have come up with really smart ways to do different kindof things in the language, but thats beside the video in hand, but you can learn more about it here:<p>brainf*ck basics: <a href=https://gist.github.com/roachhd/dce54bec8ba55fb17d3a target=_blank> https://gist.github.com/roachhd/dce54bec8ba55fb17d3a </a><p>today, we're going to write an interpreter for brainfuck, and we're going to do that in Rust.<p>first we create a new binary project using cargo.<pre class=language-sh data-lang=sh style=color:#61676c;background-color:#fafafa><code class=language-sh data-lang=sh><span style=color:#f29718>cargo</span><span> init</span><span style=color:#ff8f40> --bin --name</span><span> bf-interpreter-rs
</span></code></pre><h1 id=lexical-analysis><a aria-label="Anchor link for: lexical-analysis" class=zola-anchor href=#lexical-analysis>Lexical Analysis</a></h1><p>First we need a way to convert a long string of brainfuck operators, into series of lexical tokens. so we create a "Lexer" structure<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// Lexer
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Lexer </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Vector of tokens scanned.
</span><span>    </span><span style=color:#fa6e32>pub </span><span>tokens</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTToken>,
</span><span>}
</span></code></pre><p>it will hold a vector of all the tokens it scanned. and here's what a single token is:<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// Holds information about a token.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Token </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub </span><span>line</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>token_type</span><span style=color:#61676ccc>:</span><span> TokenType,
</span><span>}
</span></code></pre><p>it holds where the token is present in the input string, and also what type of token it is.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// All the operators which exists in brainf*ck
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug</span><span style=color:#61676ccc>,</span><span> PartialEq)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>TokenType </span><span>{
</span><span>    RightAngle</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// >
</span><span>    LeftAngle</span><span style=color:#61676ccc>,   </span><span style=color:#abb0b6;font-style:italic>// <
</span><span>    Plus</span><span style=color:#61676ccc>,        </span><span style=color:#abb0b6;font-style:italic>// +
</span><span>    Minus</span><span style=color:#61676ccc>,       </span><span style=color:#abb0b6;font-style:italic>// -
</span><span>    RightSquare</span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// ]
</span><span>    LeftSquare</span><span style=color:#61676ccc>,  </span><span style=color:#abb0b6;font-style:italic>// [
</span><span>    Comma</span><span style=color:#61676ccc>,       </span><span style=color:#abb0b6;font-style:italic>// ,
</span><span>    Dot</span><span style=color:#61676ccc>,         </span><span style=color:#abb0b6;font-style:italic>// .
</span><span>    Eof</span><span style=color:#61676ccc>,         </span><span style=color:#abb0b6;font-style:italic>// end of file.
</span><span>}
</span></code></pre><p>and here is a enum storing all the types of token a token can be, we also add a special EOF, or END OF FILE token which will come in handy later when we come to parsing.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// Scans a string into Vec of Tokens.
</span><span style=color:#abb0b6;font-style:italic>/// # Arguments
</span><span style=color:#abb0b6;font-style:italic>/// * input - Immutable reference to the string to scan.
</span><span style=color:#abb0b6;font-style:italic>/// # Returns
</span><span style=color:#abb0b6;font-style:italic>/// * tokens - Vector of Tokens scanned.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>scan_tokens</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTToken> {
</span><span>}
</span></code></pre><p>now for scanning, we create a new method on the lexer struct, "scan_tokens" it will take a string input and return a vector of tokens it scanned.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>fn </span><span style=color:#f29718>scan_tokens</span><span>(</span><span style=color:#ff8f40>input</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTToken> {
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> line </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>we will also need to store the line number we're at in the input string, we so create a local variable "line".<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>let mut</span><span> tokens </span><span style=color:#ed9366>=</span><span> input
</span></code></pre><p>and for scanning tokens, we take the input string<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>let mut</span><span> tokens </span><span style=color:#ed9366>=</span><span> input
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// taking characters
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chars</span><span>()
</span></code></pre><p>then take indiviual characters from the string<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>let mut</span><span> tokens </span><span style=color:#ed9366>=</span><span> input
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// taking characters
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chars</span><span>()
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// mapping through it
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>flat_map</span><span>(|</span><span style=color:#ff8f40>lexeme</span><span>| {})
</span></code></pre><p>and map through each character, we match each character for all the operators<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>let mut</span><span> tokens </span><span style=color:#ed9366>=</span><span> input
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// taking characters
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>chars</span><span>()
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// mapping through it
</span><span>    </span><span style=color:#ed9366>.</span><span style=color:#f07171>flat_map</span><span>(| </span><span style=color:#ff8f40>lexeme </span><span>| {
</span><span>        </span><span style=color:#86b300>'>' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>            line</span><span style=color:#61676ccc>,
</span><span>            token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>RightAngle</span><span style=color:#61676ccc>,
</span><span>        })
</span><span>    })
</span></code></pre><p>for example, if we find a right angle bracket, we create a token at current line number of type RightAngleBracket.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is >
</span><span>       </span><span style=color:#86b300>'>' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>RightAngle</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is <
</span><span>       </span><span style=color:#86b300>'<' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>LeftAngle</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is +
</span><span>       </span><span style=color:#86b300>'+' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>Plus</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is -
</span><span>       </span><span style=color:#86b300>'-' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>Minus</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is ]
</span><span>       </span><span style=color:#86b300>']' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>RightSquare</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is [
</span><span>       </span><span style=color:#86b300>'[' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>LeftSquare</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is ,
</span><span>       </span><span style=color:#86b300>',' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>Comma</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span><span>
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// if the character is .
</span><span>       </span><span style=color:#86b300>'.' </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Token {
</span><span>           line</span><span style=color:#61676ccc>,
</span><span>           token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>Dot</span><span style=color:#61676ccc>,
</span><span>       })</span><span style=color:#61676ccc>,
</span></code></pre><p>and simillary we match for <, +, -, ], [ , ",", "." and keep adding tokens at the current line number of that type,<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>       </span><span style=color:#abb0b6;font-style:italic>// if its a newline character,
</span><span>       </span><span style=color:#abb0b6;font-style:italic>// we increase line number count.
</span><span>       </span><span style=color:#86b300>'</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>' </span><span style=color:#ed9366>=> </span><span>{
</span><span>           line </span><span style=color:#ed9366>+= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>           </span><span style=color:#55b4d4;font-style:italic>None
</span><span>       }
</span></code></pre><p>but if we see a newline character, we increment the line count and return None.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>      </span><span style=color:#abb0b6;font-style:italic>// consider everything else as comments.
</span><span>      </span><span style=color:#ed9366>_ => </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span></code></pre><p>and everything else is also ignored, as we consider them as "comments"<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>        </span><span style=color:#abb0b6;font-style:italic>// consider everything else as comments.
</span><span>        </span><span style=color:#ed9366>_ => </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>    })
</span><span>    </span><span style=color:#ed9366>.</span><span>collect</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTToken>>()</span><span style=color:#61676ccc>;
</span></code></pre><p>then we collect this flat_map into a vector of tokens<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>    </span><span style=color:#abb0b6;font-style:italic>// push a EOF token at the end.
</span><span>    tokens</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(Token {
</span><span>        line</span><span style=color:#61676ccc>,
</span><span>        token_type</span><span style=color:#61676ccc>: </span><span>TokenType</span><span style=color:#ed9366>::</span><span>Eof</span><span style=color:#61676ccc>,
</span><span>    })</span><span style=color:#61676ccc>;
</span></code></pre><p>we also manually add a EOF token at the end<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>   </span><span style=color:#abb0b6;font-style:italic>// reverse tokens since we are going to pop it.
</span><span>   tokens</span><span style=color:#ed9366>.</span><span style=color:#f07171>reverse</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>   tokens
</span><span>}
</span></code></pre><p>finally we reverse the tokens vector, and return it<p>and thats the entire scanning process in one go.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>    </span><span style=color:#abb0b6;font-style:italic>/// Removes and Returns the next Token.
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>pop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-></span><span> Token {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>tokens
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>pop</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"[Lexer] Failed to get next token."</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/// Returns reference to the next Token without removing it.
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>peek</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>Token {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>tokens
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>last</span><span>()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"[Lexer] Failed to peek next token."</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>we also add these two helpers, pop and peek which we will need later<p>and now if we give our lexer a simple brainfuck program like this one<pre style=color:#61676c;background-color:#fafafa><code><span>>++.
</span><span>-.
</span></code></pre><p>it gives us meaningful tokens from the string<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> RightAngle }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Plus }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Plus }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Dot }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Minus }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Dot }
</span><span>Token { line</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>,</span><span> token_type</span><span style=color:#61676ccc>:</span><span> Eof }
</span></code></pre><p>and with that we're done with the lexer.<h1 id=parsing><a aria-label="Anchor link for: parsing" class=zola-anchor href=#parsing>Parsing</a></h1><p>Now comes "Parsing", in this process we can either create a AST or instructions from the tokens we got from the lexer. we're going to do the later.<p>we start by creating a new file, and a Parser structure<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// Parser - Parses stream of tokens into vector of instructions.
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Parser</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    lexer</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a mut</span><span> Lexer,
</span><span>    </span><span style=color:#fa6e32>pub </span><span>statements</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTStmt>,
</span><span>}
</span></code></pre><p>it consists of two fields, a mutable reference to the lexer, and a vector of statements.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// statements supported by the vm.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>Stmt </span><span>{
</span><span>    NodeStmt(OpCode)</span><span style=color:#61676ccc>,
</span><span>    WhileStmt(</span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTStmt>)</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>and a statement can be either a NodeStmt or a WhileStmt, A NodeStmt will have a operation code and a WhileStmt will have a vector of statements inside it.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// Instruction set supported by the vm.
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Debug)]
</span><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>OpCode </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// moves pointer one cell right.
</span><span>    MovePtrForward</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// moves pointer one cell left.
</span><span>    MovePtrBackward</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// reads one character from stdin.
</span><span>    ReadFromStdin</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// writes one character to stdout.
</span><span>    WriteToStdout</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// increment or decrement value at the ptr.
</span><span>    Crement(</span><span style=color:#fa6e32>i8</span><span>)</span><span style=color:#61676ccc>,
</span><span>}
</span></code></pre><p>the operations code we will allow are<ul><li>MovePtrForward - it moves the pointer one cell forward.<li>MovePtrBackward - it moves the pointer one cell backward.<li>ReadFromStdin - reads data from stdin and save it in the current cell.<li>WriteToStdout - writes current cell data to the stdout.<li>Crement - it stores a signed 8 bit value and increments or decrements the value of current cell with that value. I know i could have made two separate instructions for increment and decrement, but a abstracted instruction which can do both just feels right to me for some reason.</ul><pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// Public parse function which instiates the parsing process.
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>parse</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>while </span><span style=color:#ed9366>!</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>match_token</span><span>(TokenType</span><span style=color:#ed9366>::</span><span>Eof) {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(stmt) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>parse_stmt</span><span>() {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>statements</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(stmt)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>we create a public parse function which loops through the tokens and parses statements untill it finds a EOF token.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// matches the current token with the given type.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>match_token</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>tt</span><span style=color:#61676ccc>:</span><span>TokenType) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_at_end</span><span>() {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lexer</span><span style=color:#ed9366>.</span><span style=color:#f07171>peek</span><span>()</span><span style=color:#ed9366>.</span><span>token_type </span><span style=color:#ed9366>==</span><span> tt
</span><span>}
</span></code></pre><p>this also uses this small helper function which just matches the current token we're parsing.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// checks if there are no more tokens to parse
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>is_at_end</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool </span><span>{
</span><span>    </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lexer</span><span style=color:#ed9366>.</span><span>tokens</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_empty</span><span>()
</span><span>}
</span></code></pre><p>which internally uses this helper function, which just checks if there are not more tokens to parse.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// parses individual instruction
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>parse_stmt</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTStmt> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> current </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lexer</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>now in the parse_stmt function, we take indiviual tokens, then we match it against the types of tokens possible and return the respective statements,<p>for simple operations like move pointer one cell to the right, just simple return a NodeStmt with the corresponding operation code.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>    </span><span style=color:#fa6e32>match</span><span> current</span><span style=color:#ed9366>.</span><span>token_type {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// >
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>RightAngle </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>MovePtrForward))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// <
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>LeftAngle </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>MovePtrBackward))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// +
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>Plus </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>Crement(</span><span style=color:#ff8f40>1</span><span>)))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// -
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>Minus </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>Crement(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span>)))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// ,
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>Comma </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>ReadFromStdin))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// .
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>Dot </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(OpCode</span><span style=color:#ed9366>::</span><span>WriteToStdout))</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// for '[' we call the parse_instruction function recurisvely.
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>LeftSquare </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let mut</span><span> inner_instructions</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTStmt> </span><span style=color:#ed9366>= </span><span style=color:#f07171>vec!</span><span>[]</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#fa6e32>while </span><span style=color:#ed9366>!</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>match_token</span><span>(TokenType</span><span style=color:#ed9366>::</span><span>RightSquare) {
</span><span>                </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(instruction) </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>parse_stmt</span><span>() {
</span><span>                    inner_instructions</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(instruction)</span><span style=color:#61676ccc>;
</span><span>                }
</span><span>            }
</span><span>
</span><span>            </span><span style=color:#abb0b6;font-style:italic>// consuming ']'
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>lexer</span><span style=color:#ed9366>.</span><span style=color:#f07171>pop</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(Stmt</span><span style=color:#ed9366>::</span><span>WhileStmt(inner_instructions))
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// if we encounted a ']' without a starting ']' its a parser error.
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>RightSquare </span><span style=color:#ed9366>=> </span><span>{
</span><span>            Parser</span><span style=color:#ed9366>::</span><span>error(</span><span style=color:#86b300>"Unexpected ']'"</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>current)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None
</span><span>        }
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// shoudnt be reachable.
</span><span>        TokenType</span><span style=color:#ed9366>::</span><span>Eof </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>,
</span><span>    }
</span></code></pre><p>and for parsing left square bracket, we first create a empty vector of statements, we then recursively call the parse statement function and keep adding the parsed statements to the vector we created untill we reach a closing right square bracket<p>and since we stop the loop once we reach a closing square bracket we also need to consume that token, finnally we return the vector of parsed statement inside a WhileStmt.<p>and that parses opening and closing square brackets.<p>also for the left token types, if we find a closing square bracket without a opening square bracket, it's parses error. and EOF token shouldn't be reachable since we don't enter the parse_stmt function if we encounter one.<p>now if we give our input to lexer and then to parser,<pre style=color:#61676c;background-color:#fafafa><code><span>+-<>,.
</span></code></pre><p>we get something like this<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span>NodeStmt(Crement(</span><span style=color:#ff8f40>1</span><span>))
</span><span>NodeStmt(Crement(</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span>))
</span><span>NodeStmt(MovePtrBackward)
</span><span>NodeStmt(MovePtrForward)
</span><span>NodeStmt(ReadFromStdin)
</span><span>NodeStmt(WriteToStdout)
</span></code></pre><p>and with that, our parser is complete.<h1 id=vm><a aria-label="Anchor link for: vm" class=zola-anchor href=#vm>VM</a></h1><p>We are now at the final stage of our interpreter, a Virtual Machine, Our Virtual Machine or VM for short, has 1 job, run through the instructions, and execute them.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// Our virtual machine which will execute instructions.
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Vm</span><span><</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>    statements</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a </span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTStmt>,
</span><span>    pointer</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    data</span><span style=color:#61676ccc>:</span><span> [</span><span style=color:#fa6e32>u8</span><span>; 30000],
</span><span>}
</span></code></pre><p>for the final time, we start by creating a structure, VM, it will hold a reference to statements it needs to execute, data pointer, and u8 array of size thirty thousands.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>/// public run method to start execution
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#fa6e32>for</span><span> statement </span><span style=color:#ed9366>in </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>statements {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_stmt</span><span>(statement)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>we implement a public "run" method, which iterates through each statement and call run_statement method on them.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// runs individual statement
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_stmt</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>stmt</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Stmt) {
</span><span>    </span><span style=color:#fa6e32>match</span><span> stmt {
</span><span>        Stmt</span><span style=color:#ed9366>::</span><span>NodeStmt(op_code) </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_opcode</span><span>(op_code)</span><span style=color:#61676ccc>,
</span><span>        Stmt</span><span style=color:#ed9366>::</span><span>WhileStmt(stmts) </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>while_stmt</span><span>(stmts)</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span></code></pre><p>and here's the run_stmt method, it matches the type of statement and calls run_opcode if its a simple NodeStmt<p>the run_opcode method literally just matches the operation code which gets passed to it and directly executes, for example if the operation code is MovePtrForward, it just increments the data pointer, and for ReadFromStdin operation code, it reads from the standard input and stores them in the current cell.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#fa6e32>fn </span><span style=color:#f29718>run_opcode</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>node</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>OpCode) {
</span><span>    </span><span style=color:#fa6e32>match</span><span> node {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// moves pointer forward.
</span><span>        OpCode</span><span style=color:#ed9366>::</span><span>MovePtrForward </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer </span><span style=color:#ed9366>+= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// moves pointer backward.
</span><span>        OpCode</span><span style=color:#ed9366>::</span><span>MovePtrBackward </span><span style=color:#ed9366>=> </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer </span><span style=color:#ed9366>-= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,
</span><span>
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// reads input from stdin and writes to current pointed cell.
</span><span>        OpCode</span><span style=color:#ed9366>::</span><span>ReadFromStdin </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#fa6e32>let mut</span><span> input </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>            std</span><span style=color:#ed9366>::</span><span>io</span><span style=color:#ed9366>::</span><span>stdin()</span><span style=color:#ed9366>.</span><span style=color:#f07171>read_line</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> input)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>let</span><span> first_char </span><span style=color:#ed9366>=</span><span> input</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_bytes</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>first</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>copied</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data[</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer] </span><span style=color:#ed9366>=</span><span> first_char</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// writes current cell as char to stdout.
</span><span>        OpCode</span><span style=color:#ed9366>::</span><span>WriteToStdout </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#f07171>print!</span><span>(
</span><span>                </span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,
</span><span>                std</span><span style=color:#ed9366>::</span><span>char</span><span style=color:#ed9366>::</span><span>from_u32(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data[</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer] </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap_or</span><span>(</span><span style=color:#86b300>'0'</span><span>)
</span><span>            )
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// increments or decrements current pointed value.
</span><span>        OpCode</span><span style=color:#ed9366>::</span><span>Crement(value) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data[</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer] </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data[</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer] </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>i8 </span><span style=color:#ed9366>+</span><span> value) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u8</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>if the statement we are parsing is a whileStmt, we call while_stmt method, this loops through the instruction inside the node vector and executes them as long as the data in the currently pointed cell is not zero.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// while statements
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>while_stmt</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>node</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>Vec</span><span>&LTStmt>) {
</span><span>    </span><span style=color:#fa6e32>while </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>data[</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pointer] </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0 </span><span>{
</span><span>        </span><span style=color:#fa6e32>for</span><span> stmt </span><span style=color:#ed9366>in</span><span> node {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#f07171>run_stmt</span><span>(stmt)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>and with that our VM is ready.<h1 id=connecting-everything-into-a-beautiful-pipeline><a aria-label="Anchor link for: connecting-everything-into-a-beautiful-pipeline" class=zola-anchor href=#connecting-everything-into-a-beautiful-pipeline>Connecting everything into a beautiful pipeline.</a></h1><p>we can now create a simple top level run function, which read input from a file, and connect our lexer, our parse and finnaly our VM.<p>simple enough, here it is:<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// start the interpreter.
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>run</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// if != 2 number of arguments are passed.
</span><span>    </span><span style=color:#fa6e32>if </span><span>env</span><span style=color:#ed9366>::</span><span>args()</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>2 </span><span>{
</span><span>        </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"bfir - Brainf*ck Interpreter in Rust.</span><span style=color:#4cbf99>\n\n</span><span style=color:#86b300>Usage:</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>    bfirs [filename]"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#f07171>exit</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// read file content.
</span><span>    </span><span style=color:#fa6e32>let</span><span> file_content </span><span style=color:#ed9366>= </span><span>App</span><span style=color:#ed9366>::</span><span>get_file_contents(</span><span style=color:#ed9366>&</span><span>env</span><span style=color:#ed9366>::</span><span>args()</span><span style=color:#ed9366>.</span><span>collect</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>>()[</span><span style=color:#ff8f40>1</span><span>])</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// create a new lexer, and tokenize file string.
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> lexer </span><span style=color:#ed9366>= </span><span>Lexer</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span>file_content)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// create a new parser
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> parser </span><span style=color:#ed9366>= </span><span>Parser</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> lexer)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// parse the tokens to stmts
</span><span>    parser</span><span style=color:#ed9366>.</span><span style=color:#f07171>parse</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// creates a new vm
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> vm </span><span style=color:#ed9366>= </span><span>Vm</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span>parser</span><span style=color:#ed9366>.</span><span>statements)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// run statements.
</span><span>    vm</span><span style=color:#ed9366>.</span><span style=color:#f07171>run</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>it also uses this simple helper function to read data from the file.<pre class=language-rs data-lang=rs style=color:#61676c;background-color:#fafafa><code class=language-rs data-lang=rs><span style=color:#abb0b6;font-style:italic>// reads file content, returns string of file content otherwise panics.
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_file_contents</span><span>(</span><span style=color:#ff8f40>filepath</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-></span><span> String {
</span><span>    </span><span style=color:#fa6e32>let</span><span> contents </span><span style=color:#ed9366>= </span><span>fs</span><span style=color:#ed9366>::</span><span>read_to_string(filepath)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(file) </span><span style=color:#ed9366>=</span><span> contents {
</span><span>        </span><span style=color:#fa6e32>return</span><span> file</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"Failed to open file."</span><span>)
</span><span>}
</span></code></pre><p>and with that our whole intepreter is ready. so lets test it.<p>here's the hello world program from earlier,<pre class=language-bf data-lang=bf style=color:#61676c;background-color:#fafafa><code class=language-bf data-lang=bf><span>>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]
</span><span>>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]&LT-.--------.+++
</span><span>.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
</span></code></pre><p>lets give that to our interpreter,<p><img alt=results src=/posts/images/0004.png><p>we can see it working as we expected.<p>I have cleaned up the code a little,and pushed it to github: <a href=https://github.com/prashantrahul141/bf-interpreter-rs target=_blank> https://github.com/prashantrahul141/bf-interpreter-rs </a><p>and there are some examples in the ./examples directory for you to test the interpreter.<p>and thank you for reading!</section></article></main></div>